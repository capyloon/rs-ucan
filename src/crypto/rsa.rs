use std::str::FromStr;

use anyhow::{anyhow, Result};
use did_key::{CoreSign, Fingerprint, Generate};
use did_url::DID;
pub use pkcs1::ToRsaPublicKey;
use rsa::{pkcs8::FromPublicKey, Hash, PaddingScheme};
pub use rsa::{PublicKey, RsaPrivateKey, RsaPublicKey};

use super::SigningKey;

pub const MAGIC_BYTES: &[u8] = &[0x85, 0x24];
pub const ALGORITHM_NAME: &str = "RSASSA-PKCS1-v1_5";

fn rsa_public_key_to_fingerprint(public_key: &RsaPublicKey) -> String {
    match public_key.to_pkcs1_der() {
        Ok(public_key) => {
            let bytes = [MAGIC_BYTES, public_key.as_der()].concat();
            format!("z{}", bs58::encode(bytes).into_string())
        }
        Err(error) => {
            warn!(
                "Could not serialize RSA public key with PKCS1 encoding: {}",
                error
            );
            String::from("")
        }
    }
}

fn try_did_to_rsa_public_key(did: String) -> Result<RsaPublicKey> {
    let did = DID::from_str(did.as_str())?;

    let public_key = match did.method_id().strip_prefix("z") {
        Some(id) => bs58::decode(id).into_vec()?,
        None => return Err(anyhow!("Could not decode DID as RSA public key")),
    };

    if &public_key[0..2] == MAGIC_BYTES {
        Ok(RsaPublicKey::from_public_key_der(&public_key[2..]).unwrap())
    } else {
        Err(anyhow!("Incorrect header bytes for RSA public key"))
    }
}

/// Wraps an RsaPublicKey and optional RsaPrivateKey, and implements the
/// SigningKey trait so that an RSA key may be used to sign a UCAN. Note that
/// the constructs being wrapped are inherited from the `rsa` crate, and are
/// re-exported by this module for convenience.
pub struct RsaKeyPair(pub RsaPublicKey, pub Option<RsaPrivateKey>);

impl Fingerprint for RsaKeyPair {
    fn fingerprint(&self) -> String {
        rsa_public_key_to_fingerprint(&self.0)
    }
}

impl CoreSign for RsaKeyPair {
    fn sign(&self, payload: &[u8]) -> Vec<u8> {
        // NOTE: Should be safe to unwrap, as the result only errors when an
        // improper padding scheme is used
        match &self.1 {
            Some(private_key) => private_key
                .sign(
                    PaddingScheme::PKCS1v15Sign {
                        hash: Some(Hash::SHA2_256),
                    },
                    payload,
                )
                .unwrap(),
            None => {
                warn!("Attempt to sign without RSA private key; signature will be empty");
                Vec::new()
            }
        }
    }

    fn verify(&self, payload: &[u8], signature: &[u8]) -> Result<(), did_key::Error> {
        match self.0.verify(
            PaddingScheme::PKCS1v15Sign {
                hash: Some(Hash::SHA2_256),
            },
            payload,
            signature,
        ) {
            Err(_) => Err(did_key::Error::SignatureError),
            _ => Ok(()),
        }
    }
}

impl SigningKey for RsaKeyPair {
    fn get_jwt_algorithm_name(&self) -> String {
        ALGORITHM_NAME.into()
    }

    fn try_from_did(did: String) -> Result<Self> {
        let public_key = try_did_to_rsa_public_key(did)?;
        Ok(RsaKeyPair(public_key, None))
    }
}

#[cfg(target_arch = "wasm32")]
pub mod web {
    use anyhow::{anyhow, Result};
    use did_key::{CoreSign, Fingerprint};
    use js_sys::{Array, ArrayBuffer, Object, Reflect, Uint8Array};
    use rsa::{
        pkcs8::{FromPublicKey, SubjectPublicKeyInfo, ToPublicKey},
        RsaPublicKey,
    };
    use wasm_bindgen::JsValue;
    use wasm_bindgen_futures::JsFuture;
    use web_sys::{CryptoKey, CryptoKeyPair};

    use crate::crypto::SigningKey;

    use super::ALGORITHM_NAME;

    const SPKI_PARAMS_ENCODED: &[u8] = &[48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0];
    const ASN_SEQUENCE_TAG: &[u8] = &[0x30];
    const ASN_BITSTRING_TAG: &[u8] = &[0x03];

    /// Wraps a public CryptoKey and optional private CryptoKey with the
    /// implicit expectation that these keys represent RSA key material
    /// as generated by the WebCrypto API. The SigningKey trait is implemented
    /// for the wrapper so that such WebCrypto-generated keys may be used
    /// as conveniently as possible to sign UCANs.
    pub struct WebCryptoRsaKeyPair(pub Uint8Array, pub Option<CryptoKey>);

    impl WebCryptoRsaKeyPair {
        /// Generates a key using crypto.subtle, matching the configuration used
        /// by ts-ucan at the time of implementation
        /// See: https://github.com/ucan-wg/ts-ucan/blob/92d2281edc342f0fdec2721d8de2a36d103aa8ca/src/crypto/rsa.ts#L9-L20
        pub async fn generate() -> Result<Self> {
            let window = web_sys::window()
                .ok_or_else(|| anyhow!("Could not get a reference to document window"))?;
            let subtle_crypto = window
                .crypto()
                .map_err(|error| anyhow!("{:?}", error))?
                .subtle();
            let algorithm_config = JsValue::from(Object::new());

            Reflect::set(
                &algorithm_config,
                &JsValue::from("name"),
                &JsValue::from(ALGORITHM_NAME),
            )
            .map_err(|error| anyhow!("{:?}", error))?;

            Reflect::set(
                &algorithm_config,
                &JsValue::from("modulusLength"),
                &JsValue::from(2048i16),
            )
            .map_err(|error| anyhow!("{:?}", error))?;

            Reflect::set(
                &algorithm_config,
                &JsValue::from("publicExponent"),
                &Uint8Array::from(vec![0x01u8, 0x00, 0x01].as_slice()),
            )
            .map_err(|error| anyhow!("{:?}", error))?;

            let hash_config = JsValue::from(Object::new());

            Reflect::set(
                &hash_config,
                &JsValue::from("name"),
                &JsValue::from("SHA-256"),
            )
            .map_err(|error| anyhow!("{:?}", error))?;

            Reflect::set(&algorithm_config, &JsValue::from("hash"), &hash_config)
                .map_err(|error| anyhow!("{:?}", error))?;

            let uses = Array::new();
            uses.push(&JsValue::from("sign"));
            uses.push(&JsValue::from("verify"));

            let crypto_key_pair = subtle_crypto
                .generate_key_with_object(&Object::from(algorithm_config), false, &uses)
                .map_err(|error| anyhow!("{:?}", error))?;

            let crypto_key_pair = CryptoKeyPair::from(
                JsFuture::from(crypto_key_pair)
                    .await
                    .map_err(|error| anyhow!("{:?}", error))?,
            );

            let public_key = Reflect::get(&crypto_key_pair, &JsValue::from("publicKey"))
                .map_err(|error| anyhow!("{:?}", error))?;
            let private_key = Reflect::get(&crypto_key_pair, &JsValue::from("privateKey"))
                .map_err(|error| anyhow!("{:?}", error))?;

            let public_key = Uint8Array::from(
                JsFuture::from(
                    subtle_crypto
                        .export_key("spki", &CryptoKey::from(public_key))
                        .map_err(|error| anyhow!("{:?}", error))?,
                )
                .await
                .map_err(|error| anyhow!("{:?}", error))?,
            );

            Ok(WebCryptoRsaKeyPair(
                public_key,
                Some(CryptoKey::from(private_key)),
            ))
        }

        fn try_rsa_public_key(&self) -> Result<RsaPublicKey> {
            let key_bytes = self.0.to_vec();

            RsaPublicKey::from_spki(
                SubjectPublicKeyInfo::try_from(key_bytes.as_slice())
                    .map_err(|error| anyhow!("{:?}", error))?,
            )
            .map_err(|error| anyhow!("{:?}", error))
        }
    }

    impl SigningKey for WebCryptoRsaKeyPair {
        fn try_from_did(did: String) -> Result<Self> {
            let public_key = super::try_did_to_rsa_public_key(did)?;
            let spki = public_key.to_public_key_der()?;
            let spki = spki.spki();
            let public_key = Uint8Array::from(spki.subject_public_key);

            Ok(WebCryptoRsaKeyPair(public_key, None))
        }

        fn get_jwt_algorithm_name(&self) -> String {
            ALGORITHM_NAME.into()
        }
    }

    impl CoreSign for WebCryptoRsaKeyPair {
        fn sign(&self, payload: &[u8]) -> Vec<u8> {
            todo!()
            // match web_sys::window() {
            //     Some(window) => {
            //         match window.crypto() {
            //             Ok(crypto) => {
            //                 let subtle = crypto.subtle();
            //                 subtle.sign_with_object_and_u8_array(algorithm, key, data)
            //             },
            //             _ => warn!("Cannot get reference to window.crypto")
            //         }
            //     },
            //     None => {
            //         warn!("Cannot get reference to window");
            //     }
            // }

            // return Vec::new();
        }

        fn verify(&self, payload: &[u8], signature: &[u8]) -> Result<(), did_key::Error> {
            todo!()
        }
    }

    impl Fingerprint for WebCryptoRsaKeyPair {
        fn fingerprint(&self) -> String {
            match self.try_rsa_public_key() {
                Ok(public_key) => super::rsa_public_key_to_fingerprint(&public_key),
                Err(error) => {
                    warn!(
                        "Unable to generate fingerprint for WebCrypto RSA key: {:?}",
                        error
                    );
                    String::from("")
                }
            }
        }
    }
}
